<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src&#x2F;main&#x2F;js&#x2F;jquery.simula.js - jquery-simula</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="jquery-simula"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.4.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/EventSimulator.html">EventSimulator</a></li>
            
                <li><a href="..&#x2F;classes/jQuery.html">jQuery</a></li>
            
                <li><a href="..&#x2F;classes/jQuery.simula.html">jQuery.simula</a></li>
            
                <li><a href="..&#x2F;classes/Observable.html">Observable</a></li>
            
                <li><a href="..&#x2F;classes/Observer.html">Observer</a></li>
            
                <li><a href="..&#x2F;classes/SimulaEvent.html">SimulaEvent</a></li>
            
                <li><a href="..&#x2F;classes/SimulaMouseEvent.html">SimulaMouseEvent</a></li>
            
                <li><a href="..&#x2F;classes/Simulation.html">Simulation</a></li>
            
                <li><a href="..&#x2F;classes/Simulator.html">Simulator</a></li>
            
                <li><a href="..&#x2F;classes/SimulatorQueue.html">SimulatorQueue</a></li>
            
                <li><a href="..&#x2F;classes/SimulaUIEvent.html">SimulaUIEvent</a></li>
            
                <li><a href="..&#x2F;classes/TimeSimulator.html">TimeSimulator</a></li>
            
                <li><a href="..&#x2F;classes/W3CMouseEventSimulator.html">W3CMouseEventSimulator</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/jQuery.html">jQuery</a></li>
            
                <li><a href="..&#x2F;modules/jQuery.simula.html">jQuery.simula</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src&#x2F;main&#x2F;js&#x2F;jquery.simula.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * jQuery user input simulation. The classes are exported to jQuery.simula.
 *
 * @author Manuel Leuenberger
 * @module jQuery
 * @module jQuery.simula
 *&#x2F;

(function ($, undefined) {
	
	&#x2F;**
	 * Checks if the other&#x27;s first DOM element is the same as the calling one.
	 *
	 * @for jQuery
	 * @method equals
	 *
	 * @param {jQuery} other A jQuery object
	 *
	 * @return {Boolean} true, if the first DOM element is the same, false
	 *     otherwise
	 *&#x2F;
	$.fn.equals = function (other) {
		return this[0] == $(other)[0];
	};
	
	var check = false;
	var isRelative = true;
	
	&#x2F;**
	 * Gets the DOM element from point, as in the W3C description.
	 *
	 * @for jQuery
	 * @method elementFromPoint
	 *
	 * @param {Number} clientX The clientX coordinate
	 * @param {Number} clientY The clientY coordinate
	 *
	 * @return {DOMElement} The DOM element, if present. Null if not supported
	 *     by browser
	 *&#x2F;
	$.elementFromPoint = function (clientX, clientY) {
		&#x2F;&#x2F; return null for unsupported browsers
		if (!document.elementFromPoint) {
			return null;
		}
		&#x2F;&#x2F; check behaviour of elementFromPoint
		if (!check) {
			check = true;
			var scrollTop = $(document).scrollTop();
			var scrollLeft = $(document).scrollLeft();
			if (scrollTop &gt; 0) {
				isRelative = (document.elementFromPoint(
						0, scrollTop + $(window).height() - 1) == null);
			} else if (scrollLeft &gt; 0) {
				isRelative = (document.elementFromPoint(
						scrollLeft + $(window).width() - 1, 0) == null);
			} else {
				check = false;
			}
		}
		&#x2F;&#x2F; adjust if browser implements elementFromPoint incorrectly
		if (!isRelative) {
			clientX += $(document).scrollLeft();
			clientY += $(document).scrollTop();
		}
		return document.elementFromPoint(clientX, clientY);
	};
	
	&#x2F;**
	 * Check if the specified child is a child.
	 *
	 * @for jQuery
	 * @method isParentOf
	 *
	 * @param {jQuery} child
	 *     A jQuery object that may be a child of the parent
	 *
	 * @return {Boolean} true, if the specified child is really a child of the
	 *     parent, false otherwise
	 *&#x2F;
	$.fn.isParentOf = function (child) {
		var current = $(child);
		while (current[0] &amp;&amp; !this.equals(current)) {
			current = current.parent();
		}
		return !this.equals(child) &amp;&amp; this.equals(current);
	};
	
	&#x2F;**
	 * Creates an Observer.
	 *
	 * @for jQuery.simula
	 * @class Observer
	 * @constructor
	 *&#x2F;
	function Observer() {}
	&#x2F;**
	 * Called whenever an Observable updates its Observers.
	 *
	 * @method updateObservable
	 *
	 * @param {Observable} observable The Observable
	 * @param {Object} args The arguments passed by the observable
	 *&#x2F;
	Observer.prototype.updateObservable = function () {};
	
	&#x2F;**
	 * Creates an Observable.
	 *
	 * @for jQuery.simula
	 * @class Observable
	 * @constructor
	 *&#x2F;
	function Observable() {
		&#x2F;**
		 * The Observers.
		 *
		 * @property observers
		 * @type {Array}
		 * @default []
		 *&#x2F;
		this.observers = [];
	}
	&#x2F;**
	 * Updates all Observers this the specified arguments.
	 *
	 * @method updateObservers
	 *
	 * @param {Object} args The arguments to pass to the Observers
	 *&#x2F;
	Observable.prototype.updateObservers = function (args) {
		for (var i = 0; i &lt; this.observers.length; i++) {
			this.observers[i].updateObservable(this, args);
		}
	};
	&#x2F;**
	 * Adds an Observer. If it is already registered, it will not be added
	 * again.
	 *
	 * @method addObserver
	 *
	 * @param {Observer} observer The observer to add
	 *&#x2F;
	Observable.prototype.addObserver = function (observer) {
		for (var i = 0; i &lt; this.observers.length; i++) {
			var registered = this.observers[i];
			if (registered == observer) {
				return;
			}
		}
		this.observers.push(observer);
	};
	&#x2F;**
	 * Removes an Observer. If it is not already registered, it will not have no
	 * effect.
	 *
	 * @method removeObserver
	 *
	 * @param {Observer} observer The observer to remove
	 *&#x2F;
	Observable.prototype.removeObserver = function (observer) {
		for (var i = 0; i &lt; this.observers.length; i++) {
			var registered = this.observers[i];
			if (registered == observer) {
				this.observers.splice(i, 1);
				return;
			}
		}
	};
	
	&#x2F;**
	 * Creates a SimulaEvent. Properties are taken from
	 * http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;DOM-Level-2-Events&#x2F;events.html#Events-Event.
	 *
	 * @for jQuery.simula
	 * @class SimulaEvent
	 * @constructor
	 *
	 * @param {Object} options The options to use for the event. If some
	 *     properties are missing, the default values are used. It must contain
	 *     a type property
	 *&#x2F;
	function SimulaEvent(options) {
		var fullOptions = $.extend({}, {
			bubbles: true,
			cancelable: true
		}, options);
		
		&#x2F;**
		 * The name of the event (case-insensitive). The name must be an XML
		 * name.
		 *
		 * @property type
		 * @type {String}
		 *&#x2F;
		this.type = fullOptions.type;
		&#x2F;**
		 * Used to indicate whether or not an event is a bubbling event. If the
		 * event can bubble the value is true, else the value is false.
		 *
		 * @property bubbles
		 * @type {Boolean}
		 * @default true
		 *&#x2F;
		this.bubbles = fullOptions.bubbles;
		&#x2F;**
		 * Used to indicate whether or not an event can have its default action
		 * prevented. If the default action can be prevented the value is true,
		 * else the value is false.
		 *
		 * @property cancelable
		 * @type {Boolean}
		 * @default true
		 *&#x2F;
		this.cancelable = fullOptions.cancelable;
	}
	SimulaEvent.PHASE = {
		&#x2F;**
		 * Capturing phase.
		 *
		 * @static
		 * @property PHASE.CAPTURING
		 * @type {NUMBER}
		 * @default 1
		 *&#x2F;
		CAPTURING: 1,
		&#x2F;**
		 * At target phase.
		 *
		 * @static
		 * @property PHASE.AT_TARGET
		 * @type {NUMBER}
		 * @default 2
		 *&#x2F;
		AT_TARGET: 2,
		&#x2F;**
		 * Bubbling phase.
		 *
		 * @static
		 * @property PHASE.BUBBLING
		 * @type {NUMBER}
		 * @default 3
		 *&#x2F;
		BUBBLING: 3
	};
	
	&#x2F;**
	 * Creates an SimulaUIEvent. Properties are taken from
	 * http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;DOM-Level-2-Events&#x2F;events.html#Events-SimulaUIEvent.
	 *
	 * @for jQuery.simula
	 * @class SimulaUIEvent
	 * @constructor
	 *
	 * @param {Object} options The options to use for the event. If some
	 *     properties are missing, the default values are used.
	 *&#x2F;
	function SimulaUIEvent(options) {
		SimulaEvent.apply(this, [options]);
		
		var fullOptions = $.extend({}, {
			view: window,
			detail: 0
		}, options);
		
		&#x2F;**
		 * The view attribute identifies the AbstractView from which the event
		 * was generated.
		 *
		 * @property view
		 * @type {Object}
		 * @default window
		 *&#x2F;
		this.view = fullOptions.view;
		&#x2F;**
		 * Specifies some detail information about the Event, depending on the
		 * type of event.
		 *
		 * @property detail
		 * @type {Number}
		 * @default 0
		 *&#x2F;
		this.detail = fullOptions.detail;
	}
	SimulaUIEvent.prototype = new SimulaEvent();
	SimulaUIEvent.prototype.constructor = SimulaUIEvent;
	
	&#x2F;**
	 * Creates a SimulaMouseEvent. Properties are taken from
	 * http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;DOM-Level-2-Events&#x2F;events.html#Events-
	 * SimulaMouseEvent.
	 *
	 * @for jQuery.simula
	 * @class SimulaMouseEvent
	 * @constructor
	 *
	 * @param {Object} options The options to use for the event. If some
	 *     properties are missing, the default values are used.
	 *&#x2F;
	function SimulaMouseEvent(options) {
		SimulaUIEvent.apply(this, [options]);
		
		var fullOptions = $.extend({}, {
			screenX: 0,
			screenY: 0,
			clientX: 0,
			clientY: 0,
			ctrlKey: false,
			shiftKey: false,
			altKey: false,
			metaKey: false,
			button: $.simula.SimulaMouseEvent.BUTTON.LEFT,
			relatedTarget: document
		}, options);
		
		&#x2F;**
		 * The horizontal coordinate at which the event occurred relative to the
		 * origin of the screen coordinate system.
		 *
		 * @property screenX
		 * @type {Number}
		 * @default 0
		 *&#x2F;
		this.screenX = fullOptions.screenX;
		&#x2F;**
		 * The vertical coordinate at which the event occurred relative to the
		 * origin of the screen coordinate system.
		 *
		 * @property screenY
		 * @type {Number}
		 * @default 0
		 *&#x2F;
		this.screenY = fullOptions.screenY;
		&#x2F;**
		 * The horizontal coordinate at which the event occurred relative to the
		 * DOM implementation&#x27;s client area.
		 *
		 * @property clientX
		 * @type {Number}
		 * @default 0
		 *&#x2F;
		this.clientX = fullOptions.clientX;
		&#x2F;**
		 * The vertical coordinate at which the event occurred relative to the
		 * DOM implementation&#x27;s client area.
		 *
		 * @property client&gt;
		 * @type {Number}
		 * @default 0
		 *&#x2F;
		this.clientY = fullOptions.clientY;
		&#x2F;**
		 * Used to indicate whether the &#x27;ctrl&#x27; key was depressed during the
		 * firing of the event.
		 *
		 * @property ctrlKey
		 * @type {Boolean}
		 * @default false
		 *&#x2F;
		this.ctrlKey = fullOptions.ctrlKey;
		&#x2F;**
		 * Used to indicate whether the &#x27;shift&#x27; key was depressed during the
		 * firing of the event.
		 *
		 * @property shiftKey
		 * @type {Boolean}
		 * @default false
		 *&#x2F;
		this.shiftKey = fullOptions.shiftKey;
		&#x2F;**
		 * Used to indicate whether the &#x27;alt&#x27; key was depressed during the
		 * firing of the event. On some platforms this key may map to an
		 * alternative key name.
		 *
		 * @property altKey
		 * @type {Boolean}
		 * @default false
		 *&#x2F;
		this.altKey = fullOptions.altKey;
		&#x2F;**
		 * Used to indicate whether the &#x27;meta&#x27; key was depressed during the
		 * firing of the event. On some platforms this key may map to an
		 * alternative key name.
		 *
		 * @property metaKey
		 * @type {Boolean}
		 * @default false
		 *&#x2F;
		this.metaKey = fullOptions.metaKey;
		&#x2F;**
		 * During mouse events caused by the depression or release of a mouse
		 * button, button is used to indicate which mouse button changed state.
		 * The values for button range from zero to indicate the left button of
		 * the mouse, one to indicate the middle button if present, and two to
		 * indicate the right button. For mice configured for left handed use in
		 * which the button actions are reversed the values are instead read
		 * from right to left.
		 * Use $.simula.MOUSE.BUTTON.[LEFT | MIDDLE | RIGHT].
		 *
		 * @property button
		 * @type {Number}
		 * @default $.simula.MOUSE.BUTTON.LEFT
		 *&#x2F;
		this.button = fullOptions.button;
		&#x2F;**
		 * Used to identify a secondary EventTarget related to a UI event.
		 * Currently this attribute is used with the mouseover event to indicate
		 * the EventTarget which the pointing device exited and with the
		 * mouseout event to indicate the EventTarget which the pointing device
		 * entered.
		 *
		 * @property relatedTarget
		 * @type {Object}
		 * @default document
		 *&#x2F;
		this.relatedTarget = fullOptions.relatedTarget;
	}
	SimulaMouseEvent.prototype = new SimulaUIEvent();
	SimulaMouseEvent.prototype.constructor = SimulaMouseEvent;
	SimulaMouseEvent.BUTTON = {
		&#x2F;**
		 * Left mouse button.
		 *
		 * @static
		 * @property BUTTON.LEFT
		 * @type {NUMBER}
		 * @default 0
		 *&#x2F;
		LEFT: 0,
		&#x2F;**
		 * Middle mouse button.
		 *
		 * @static
		 * @property BUTTON.MIDDLE
		 * @type {NUMBER}
		 * @default 1
		 *&#x2F;
		MIDDLE: 1,
		&#x2F;**
		 * Right mouse button.
		 *
		 * @static
		 * @property BUTTON.RIGHT
		 * @type {NUMBER}
		 * @default 2
		 *&#x2F;
		RIGHT: 2
	};
	SimulaMouseEvent.TYPE = {
		&#x2F;**
		 * Mouse click event.
		 *
		 * @static
		 * @property TYPE.CLICK
		 * @type {String}
		 * @default &quot;click&quot;
		 *&#x2F;
		CLICK: &#x27;click&#x27;,
		&#x2F;**
		 * Mouse down event.
		 *
		 * @static
		 * @property TYPE.DOWN
		 * @type {String}
		 * @default &quot;mousedown&quot;
		 *&#x2F;
		DOWN: &#x27;mousedown&#x27;,
		&#x2F;**
		 * Mouse up event.
		 *
		 * @static
		 * @property TYPE.UP
		 * @type {String}
		 * @default &quot;mouseup&quot;
		 *&#x2F;
		UP: &#x27;mouseup&#x27;,
		&#x2F;**
		 * Mouse over event.
		 *
		 * @static
		 * @property TYPE.OVER
		 * @type {String}
		 * @default &quot;mouseover&quot;
		 *&#x2F;
		OVER: &#x27;mouseover&#x27;,
		&#x2F;**
		 * Mouse out event.
		 *
		 * @static
		 * @property TYPE.OUT
		 * @type {String}
		 * @default &quot;mouseout&quot;
		 *&#x2F;
		OUT: &#x27;mouseout&#x27;,
		&#x2F;**
		 * Mouse move event.
		 *
		 * @static
		 * @property TYPE.MOVE
		 * @type {String}
		 * @default &quot;mousemove&quot;
		 *&#x2F;
		MOVE: &#x27;mousemove&#x27;
	};
	
	&#x2F;**
	 * Creates a Simulator.
	 *
	 * @for jQuery.simula
	 * @class Simulator
	 * @constructor
	 *&#x2F;
	function Simulator() {
		Observable.apply(this);
		
		&#x2F;**
		 * true, if it is running.
		 *
		 * @property running
		 * @type {Boolean}
		 * @default false
		 *&#x2F;
		this.running = false;
	}
	Simulator.prototype = new Observable();
	Simulator.prototype.constructor = Simulator;
	&#x2F;**
	 * Updates all Observers with &#x27;finish&#x27;.
	 *
	 * @method finish
	 *&#x2F;
	Simulator.prototype.finish = function () {
		this.running = false;
		this.updateObservers(&#x27;finish&#x27;);
	};
	&#x2F;**
	 * Starts the the simulation, i.e. dispatches events. Must call finish, at
	 * the end.
	 *
	 * @method execute
	 *
	 * @throws {Error} If it is already running
	 *&#x2F;
	Simulator.prototype.execute = function () {
		if (this.isRunning()) {
			throw new Error(&#x27;Simulator is already running&#x27;);
		}
		this.running = true;
	};
	&#x2F;**
	 * Finishes the simulation even if its running. Doesn&#x27;t do anything if not.
	 *
	 * @method stop
	 *&#x2F;
	Simulator.prototype.stop = function () {
		if (this.isRunning()) {
			this.running = false;
			this.updateObservers(&#x27;stop&#x27;);
		}
	};
	&#x2F;**
	 * Checks if it is running.
	 *
	 * @method isRunning
	 *
	 * @return {Boolean} true, if it is, false otherwise
	 *&#x2F;
	Simulator.prototype.isRunning = function () {
		return this.running;
	};
	
	&#x2F;**
	 * Creates a SimulatorQueue.
	 *
	 * @for jQuery.simula
	 * @class SimulatorQueue
	 * @constructor
	 *
	 * @param {Array} simulators An ordered Array of Simulators which will be
	 *     executed one after another
	 *&#x2F;
	function SimulatorQueue(simulators) {
		Simulator.apply(this);
		
		&#x2F;**
		 * The Simulators.
		 *
		 * @property simulators
		 * @type {Array}
		 *&#x2F;
		this.simulators = simulators;
		&#x2F;**
		 *	The index of the current Simulator.
		 *
		 * @property currentIndex
		 * @type {Number}
		 * @default -1
		 *&#x2F;
		this.currentIndex = -1;
	}
	SimulatorQueue.prototype = new Simulator();
	SimulatorQueue.prototype.constructor = SimulatorQueue;
	SimulatorQueue.prototype.updateObservable = function (observable, args) {
		if (args != &#x27;finish&#x27; || this.currentIndex &lt; 0
				|| this.currentIndex &gt;= this.simulators.length
				|| observable != this.simulators[this.currentIndex]) {
			return;
		}
		var simulator = this.simulators[this.currentIndex];
		simulator.removeObserver(this);
		if (this.currentIndex &lt;  this.simulators.length - 1) {
			this.proceed();
		} else {
			this.finish();
		}
	};
	SimulatorQueue.prototype.finish = function () {
		this.currentIndex = -1;
		Simulator.prototype.finish.apply(this);
	};
	SimulatorQueue.prototype.execute = function () {
		Simulator.prototype.execute.apply(this);
		if (this.simulators.length &gt; 0) {
			this.proceed();
		} else {
			this.finish();
		}
	};
	SimulatorQueue.prototype.stop = function () {
		if (this.isRunning()) {
			var simulator = this.simulators[this.currentIndex];
			simulator.stop();
			this.currentIndex = -1;
		}
		Simulator.prototype.stop.apply(this);
	};
	&#x2F;**
	 * Proceeds with the execution of the next Simulator.
	 *
	 * @method proceed
	 *&#x2F;
	SimulatorQueue.prototype.proceed = function () {
		this.currentIndex++;
		var simulator = this.simulators[this.currentIndex];
		simulator.addObserver(this);
		simulator.execute();
	};
	
	&#x2F;**
	 * Creates a TimeSimulator.
	 *
	 * @for jQuery.simula
	 * @class TimeSimulator
	 * @constructor
	 *
	 * @param {Number} time The amount of milliseconds to wait before the
	 *     Observers are updated
	 *&#x2F;
	function TimeSimulator(time) {
		Simulator.apply(this);
		
		&#x2F;**
		 * The amount of milliseconds to wait before the Observers are updated.
		 *
		 * @property time
		 * @type {Number}
		 *&#x2F;
		this.time = time;
		&#x2F;**
		 * The id of the timeout.
		 *
		 * @private
		 * @property relatedTarget
		 * @type {Object}
		 * @default null
		 *&#x2F;
		this.timeoutId = null;
	}
	TimeSimulator.prototype = new Simulator();
	TimeSimulator.prototype.constructor = TimeSimulator;
	TimeSimulator.prototype.execute = function () {
		Simulator.prototype.execute.apply(this);
		this.timeoutId = setTimeout($.proxy(function () {
			this.finish();
		}, this), this.time);
	};
	TimeSimulator.prototype.stop = function () {
		if (this.isRunning()) {
			clearTimeout(this.timeoutId);
		}
		Simulator.prototype.stop.apply(this);
	};
	
	&#x2F;**
	 * Creates an EventSimulator.
	 *
	 * @for jQuery.simula
	 * @class EventSimulator
	 * @constructor
	 *
	 * @param {jQuery} $element The jQuery element on which to dispatch the
	 *     event
	 * @param {SimulaEvent} simulaEvent The SimulaEvent to init and dispatch
	 *&#x2F;
	function EventSimulator($element, simulaEvent) {
		Simulator.apply(this);
		
		&#x2F;**
		 * The jQuery element on which to dispatch the event.
		 *
		 * @property $element
		 * @type {jQuery}
		 *&#x2F;
		this.$element = $element;
		&#x2F;**
		 * The SimulaEvent to init and dispatch.
		 *
		 * @property simulaEvent
		 * @type {SimulaEvent}
		 *&#x2F;
		this.simulaEvent = simulaEvent;
		&#x2F;**
		 * The listener to add and remove.
		 *
		 * @property listener
		 * @type {Function}
		 * @default function () {}
		 *&#x2F;
		this.listener = function () {};
		&#x2F;**
		 * The Event that is dispatched.
		 *
		 * @property event
		 * @type {Event}
		 * @default null
		 *&#x2F;
		this.event = null;
	}
	EventSimulator.prototype = new Simulator();
	EventSimulator.prototype.constructor = EventSimulator;
	&#x2F;**
	 * Template method that builds the Event.
	 *
	 * @method buildEvent
	 *
	 * @return {Event} An Event that can be dispatched by dispatchEvent
	 *&#x2F;
	EventSimulator.prototype.buildEvent = function () {
		return null;
	};
	&#x2F;**
	 * Template method to add an event listener for the specified Event.
	 *
	 * @method addEventListener
	 *&#x2F;
	EventSimulator.prototype.addEventListener = function () {
		
	};
	&#x2F;**
	 * Template method to remove an event listener for the specified Event.
	 *
	 * @method removeEventListener
	 *&#x2F;
	EventSimulator.prototype.removeEventListener = function () {
		
	};
	&#x2F;**
	 * Event listener that calls finish if the specified Event is the one that
	 * was dispatched.
	 *
	 * @method handleEvent
	 *
	 * @param {Event} event The Event that was found
	 *&#x2F;
	EventSimulator.prototype.handleEvent = function (event) {
		if (event == this.event) {
			this.removeEventListener(event);
			this.listener = function () {};
			this.event = null;
			this.finish();
		}
	};
	&#x2F;**
	 * Template method that dispatches an Event.
	 *
	 * @method dispatchEvent
	 *
	 * @param {Event} event The event to be dispatched
	 *&#x2F;
	EventSimulator.prototype.dispatchEvent = function () {};
	EventSimulator.prototype.execute = function () {
		Simulator.prototype.execute.apply(this);
		this.event = this.buildEvent();
		this.listener = $.proxy(function (event) {
			this.handleEvent(event);
		}, this);
		this.addEventListener();
		this.dispatchEvent();
	};
	
	&#x2F;**
	 * Creates an W3CMouseEventSimulator.
	 *
	 * @for jQuery.simula
	 * @class W3CMouseEventSimulator
	 * @constructor
	 *
	 * @param {jQuery} $element The jQuery element on which to dispatch the
	 *     event
	 * @param {SimulaMouseEvent} mouseEvent The SimulaMouseEvent to init and
	 *     dispatch
	 *&#x2F;
	function W3CMouseEventSimulator($element, mouseEvent) {
		EventSimulator.apply(this, [$element, mouseEvent]);
	}
	W3CMouseEventSimulator.prototype = new EventSimulator();
	W3CMouseEventSimulator.prototype.constructor = W3CMouseEventSimulator;
	W3CMouseEventSimulator.prototype.buildEvent = function () {
		var mouseEvent = this.simulaEvent;
		var event = document.createEvent(&#x27;MouseEvents&#x27;);
		event.initMouseEvent(
			mouseEvent.type,
			mouseEvent.bubbles,
			mouseEvent.cancelable,
			mouseEvent.view,
			mouseEvent.detail,
			mouseEvent.screenX,
			mouseEvent.screenY,
			mouseEvent.clientX,
			mouseEvent.clientY,
			mouseEvent.ctrlKey,
			mouseEvent.altKey,
			mouseEvent.shiftKey,
			mouseEvent.metaKey,
			mouseEvent.button,
			mouseEvent.relatedTarget
		);
		return event;
	};
	W3CMouseEventSimulator.prototype.addEventListener = function () {
		this.$element.get(0).addEventListener(this.event.type, this.listener,
			false);
	};
	W3CMouseEventSimulator.prototype.removeEventListener = function () {
		this.$element.get(0).removeEventListener(this.event.type, this.listener,
			false);
	};
	W3CMouseEventSimulator.prototype.dispatchEvent = function () {
		this.$element.get(0).dispatchEvent(this.event);
	};
	
	&#x2F;&#x2F; TODO browser detection if non w3c compliant
	var MouseEventSimulator = W3CMouseEventSimulator;
	
	&#x2F;**
	 * Creates a Simulation. Moves a pixel per millisecond. Note that the
	 * internal $element and elementPosition only reflect the current state
	 * during construction&#x2F;chaining of the Simulation. This means that these
	 * stay the same during execution.
	 *
	 * @for jQuery.simula
	 * @class Simulation
	 * @constructor
	 *
	 * @param {jQuery} $element The jQuery element over which the mouse is
	 * @param {Array} elementPosition The mouse position [x, y] relative to the
	 *     specified element
	 *&#x2F;
	function Simulation($element, elementPosition) {
		Simulator.apply(this);
		
		&#x2F;**
		 * The internally used SimulatorQueue.
		 *
		 * @private
		 * @property simulatorQueue
		 * @type {SimulatorQueue}
		 * @default new SimulatorQueue([])
		 *&#x2F;
		this.simulatorQueue = new SimulatorQueue([]);
		&#x2F;**
		 * The jQuery element over which the mouse is.
		 *
		 * @property $element
		 * @type {jQuery}
		 *&#x2F;
		this.$element = $element;
		&#x2F;**
		 * The mouse position relative to the specified element.
		 *
		 * @property elementPosition
		 * @type {Array}
		 *&#x2F;
		this.elementPosition = [elementPosition[0], elementPosition[1]];
	}
	Simulation.prototype = new Simulator();
	Simulation.prototype.constructor = Simulation;
	Simulation.prototype.updateObservable = function (observable, args) {
		if (args != &#x27;finish&#x27; || observable != this.simulatorQueue) {
			return;
		}
		this.simulatorQueue.removeObserver(this);
		this.finish();
	};
	Simulation.prototype.execute = function () {
		Simulator.prototype.execute.apply(this);
		this.simulatorQueue.addObserver(this);
		this.simulatorQueue.execute();
	};
	&#x2F;**
	 * Waits for the specified duration before executing the next command.
	 *
	 * @method wait
	 *
	 * @param {Number} [duration=500] The duration in milliseconds
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.wait = function (duration) {
		if (!duration) {
			duration = 50;
		}
		this.simulatorQueue.simulators.push(new TimeSimulator(duration));
		
		return this;
	};
	&#x2F;**
	 * Adds exactly one mousemove with the specified options and element.
	 *
	 * @method mousemove
	 *
	 * @param {jQuery} [$element] The element to move on, must be added to the
	 *     DOM
	 * @param {Object} [options] The options to pass to the MouseEventSimulator
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.mousemove = function ($element, options) {
		&#x2F;&#x2F; init optional arguments
		if (!options) {
			options = {};
		}
		if (!$element) {
			$element = this.$element;
		}
		&#x2F;&#x2F; setup event
		var event = new SimulaMouseEvent($.extend({}, options, {
			type: SimulaMouseEvent.TYPE.MOVE,
			cancelable: false
		}));
		this.simulatorQueue.simulators.push(
				new MouseEventSimulator($element, event));
		return this;
	};
	&#x2F;**
	 * Adds exactly one mouseover with the specified options and element.
	 *
	 * @method mouseover
	 *
	 * @param {jQuery} [$element] The element to move over on, must be added to
	 *     the DOM
	 * @param {Object} [options] The options to pass to the MouseEventSimulator
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.mouseover = function ($element, options) {
		&#x2F;&#x2F; init optional arguments
		if (!options) {
			options = {};
		}
		if (!$element) {
			$element = this.$element;
		}
		&#x2F;&#x2F; setup event
		var event = new SimulaMouseEvent($.extend({}, options, {
			type: SimulaMouseEvent.TYPE.OVER
		}));
		this.simulatorQueue.simulators.push(
				new MouseEventSimulator($element, event));
		return this;
	};
	&#x2F;**
	 * Adds exactly one mouseout with the specified options and element.
	 *
	 * @method mouseout
	 *
	 * @param {jQuery} [$element] The element to move out, must be added to the
	 *     DOM
	 * @param {Object} [options] The options to pass to the MouseEventSimulator
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.mouseout = function ($element, options) {
		&#x2F;&#x2F; init optional arguments
		if (!options) {
			options = {};
		}
		if (!$element) {
			$element = this.$element;
		}
		&#x2F;&#x2F; setup event
		var event = new SimulaMouseEvent($.extend({}, options, {
			type: SimulaMouseEvent.TYPE.OUT
		}));
		this.simulatorQueue.simulators.push(
				new MouseEventSimulator($element, event));
		return this;
	};
	&#x2F;**
	 * Adds exactly one mousedown with the specified options and element.
	 *
	 * @method mousedown
	 *
	 * @param {jQuery} [$element] The element to press the mouse down, must be
	 *     added to the DOM
	 * @param {Object} [options] The options to pass to the MouseEventSimulator
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.mousedown = function ($element, options) {
		&#x2F;&#x2F; init optional arguments
		if (!options) {
			options = {};
		}
		if (!$element) {
			$element = this.$element;
		}
		&#x2F;&#x2F; setup event
		var event = new SimulaMouseEvent($.extend({
			button: SimulaMouseEvent.BUTTON.LEFT
		}, options, {
			type: SimulaMouseEvent.TYPE.DOWN
		}));
		this.simulatorQueue.simulators.push(
				new MouseEventSimulator($element, event));
		return this;
	};
	&#x2F;**
	 * Adds exactly one mouseup with the specified options and element.
	 *
	 * @method mouseup
	 *
	 * @param {jQuery} [$element] The element to release the mouse up, must be
	 *     added to the DOM
	 * @param {Object} [options] The options to pass to the MouseEventSimulator
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.mouseup = function ($element, options) {
		&#x2F;&#x2F; init optional arguments
		if (!options) {
			options = {};
		}
		if (!$element) {
			$element = this.$element;
		}
		&#x2F;&#x2F; setup event
		var event = new SimulaMouseEvent($.extend({
			button: SimulaMouseEvent.BUTTON.LEFT
		}, options, {
			type: SimulaMouseEvent.TYPE.UP
		}));
		this.simulatorQueue.simulators.push(
				new MouseEventSimulator($element, event));
		return this;
	};
	&#x2F;**
	 * Adds exactly one click with the specified options and element.
	 *
	 * @method mouseclick
	 *
	 * @param {jQuery} [$element] The element to click on, must be added to the
	 *     DOM
	 * @param {Object} [options] The options to pass to the MouseEventSimulator
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.mouseclick = function ($element, options) {
		&#x2F;&#x2F; init optional arguments
		if (!options) {
			options = {};
		}
		if (!$element) {
			$element = this.$element;
		}
		&#x2F;&#x2F; setup event
		var event = new SimulaMouseEvent($.extend({
			button: SimulaMouseEvent.BUTTON.LEFT
		}, options, {
			type: SimulaMouseEvent.TYPE.CLICK
		}));
		this.simulatorQueue.simulators.push(
				new MouseEventSimulator($element, event));
		return this;
	};
	&#x2F;**
	 * Moves the mouse to the specified position in the specified duration by
	 * dispatching a mousemove every 15 milliseconds.
	 *
	 * @method move
	 *
	 * @param {Array} elementPosition The mouse position [x, y] relative to the
	 *     current element
	 * @param {Number} [duration] The time to use to move to the specified
	 *     position in milliseconds
	 * @param {Object} [options] The options to pass to the MouseEventSimulator
	 * @param {Boolean} [auto=false] The mouse move mode. If true, whenever the
	 *     mouse moves over and out of an element, it dispatches the according
	 *     event and sets the internal $element and elementPosition
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.move = function (elementPosition, duration, options,
		auto) {
		var dX = elementPosition[0] - this.elementPosition[0];
		var dY = elementPosition[1] - this.elementPosition[1];
			
		&#x2F;&#x2F; init optional arguments
		if (!duration) {
			duration = Math.sqrt(dX * dX + dY * dY);
		}
		if (!options) {
			options = {};
		}
		
		&#x2F;&#x2F; add intermediate moves
		var moves = [];
		var time = 15;
		while (time &lt;= duration) {
			moves.push({
				wait: 15,
				dPosition: [time &#x2F; duration * dX, time &#x2F; duration * dY]
			});
			time += 15;
		}
		if (duration % 15 !== 0) {
			moves.push({
				wait: duration % 15,
				dPosition: [dX, dY]
			});
		}
		
		var startPosition = [this.$element.offset().left
				+ this.elementPosition[0], this.$element.offset().top
				+ this.elementPosition[1]];
		for (var i = 0; i &lt; moves.length; i++) {
			var move = moves[i];
			var clientX = startPosition[0] + move.dPosition[0];
			var clientY = startPosition[1] + move.dPosition[1];
			this.wait(move.wait);
			var $elementUnderMouse = $($.elementFromPoint(clientX, clientY));
			if (auto &amp;&amp; !this.$element.equals($elementUnderMouse)) {
				if ($elementUnderMouse.isParentOf(this.$element)
						|| !this.$element.isParentOf($elementUnderMouse)) {
					this.mouseout(this.$element, $.extend({}, options, {
						clientX: clientX,
						clientY: clientY,
						relatedTarget: $elementUnderMouse.get(0)
					}));
				}
				if (this.$element.isParentOf($elementUnderMouse)
						|| !$elementUnderMouse.isParentOf(this.$element)) {
					this.mouseover($elementUnderMouse, $.extend({}, options, {
						clientX: clientX,
						clientY: clientY,
						relatedTarget: this.$element.get(0)
					}));
				}
				this.$element = $elementUnderMouse;
			}
			this.mousemove(this.$element, $.extend({}, options, {
				clientX: clientX,
				clientY: clientY
			}));
			this.elementPosition = [clientX - this.$element.offset().left,
					clientY - this.$element.offset().top];
		}
		
		return this;
	};
	&#x2F;**
	 * Moves the mouse over the specified element.
	 *
	 * @method enter
	 *
	 * @param {jQuery} $element The element to move over, must be added to the
	 *     DOM
	 * @param [options] The options to pass to the MouseEventSimulator
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.enter = function ($element, options) {
		if (!options) {
			options = {};
		}
		if (this.$element.isParentOf($element)) {
			&#x2F;&#x2F; base case
			var parents = [];
			$element.parents().each(function () {
				parents.push($(this));
			});
			var $toEnter = parents.pop();
			while (!$toEnter.equals(this.$element)) {
				$toEnter = parents.pop();
			}
			$toEnter = parents.pop() || $element;
			var pX = $toEnter.offset().left - this.$element.offset().left
					+ $toEnter.width() &#x2F; 2;
			var pY = $toEnter.offset().top - this.$element.offset().top
					+ $toEnter.height() &#x2F; 2;
			this.move([pX, pY]);
			this.mouseover($toEnter, $.extend({}, options, {
				clientX: this.$element.offset().left + pX,
				clientY: this.$element.offset().top + pY,
				relatedTarget: this.$element.get(0)
			}));
			this.$element = $toEnter;
			this.elementPosition = [$toEnter.width() &#x2F; 2,
					$toEnter.height() &#x2F; 2];
			&#x2F;&#x2F; proceed in stack
			if (!this.$element.equals($element)) {
				this.enter($element);
			}
		} else {
			&#x2F;&#x2F; leave current stack
			this.leave(this.$element);
			this.enter($element);
		}
		return this;
	};
	&#x2F;**
	 * Moves the mouse out of the specified element.
	 *
	 * @method leave
	 *
	 * @param {jQuery} [$element] The element to move out, must be added to the
	 *     DOM
	 * @param {Object} [options] The options to pass to the MouseEventSimulator
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.leave = function ($element, options) {
		if (!$element) {
			$element = this.$element;
		}
		if (!options) {
			options = {};
		}
		if ($element.isParentOf(this.$element)
				|| $element.equals(this.$element)) {
			&#x2F;&#x2F; base case
			var $toLeave = this.$element;
			var $toLeaveParent = this.$element.parent();
			var pX = $toLeaveParent.width() &#x2F; 2
					- ($toLeave.offset().left - $toLeaveParent.offset().left);
			var pY = $toLeaveParent.height() &#x2F; 2
					- ($toLeave.offset().top - $toLeaveParent.offset().top);
			this.move([pX, pY]);
			this.mouseout($toLeave, $.extend({}, options, {
				clientX: $toLeave.offset().left + pX,
				clientY: $toLeave.offset().top + pY,
				relatedTarget: $toLeaveParent.get(0)
			}));
			this.$element = $toLeaveParent;
			this.elementPosition = [$toLeaveParent.width() &#x2F; 2,
					$toLeaveParent.height() &#x2F; 2];
			&#x2F;&#x2F; leave current in stack
			if (!this.$element.equals($element.parent())) {
				this.leave($element);
			}
		} else {
			&#x2F;&#x2F; proceed in stack
			this.enter($element);
			this.leave($element);
		}
		return this;
	};
	&#x2F;**
	 * Presses a mouse button while over an element.
	 *
	 * @method press
	 *
	 * @param {jQuery} [$element] The element to press the mouse button on. It
	 *     will be entered, if it is not already on it
	 * @param {Object} [options] The options to pass to the MouseEventSimulator
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.press = function ($element, options) {
		if (!$element) {
			$element = this.$element;
		}
		if (!options) {
			options = {};
		}
		if (!this.$element.equals($element)) {
			this.enter($element);
		}
		this.mousedown(this.$element, $.extend({}, options, {
			clientX: this.$element.offset().left + this.elementPosition[0],
			clientY: this.$element.offset().top + this.elementPosition[1]
		}));
		
		return this;
	};
	&#x2F;**
	 * Releases a mouse button while over an element.
	 *
	 * @method release
	 *
	 * @param {jQuery} [$element] The element to release the mouse button on. It
	 *     will be entered, if it is not already on it
	 * @param {Object} [options] The options to pass to the MouseEventSimulator
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.release = function ($element, options) {
		if (!$element) {
			$element = this.$element;
		}
		if (!options) {
			options = {};
		}
		if (!this.$element.equals($element)) {
			this.enter($element);
		}
		this.mouseup(this.$element, $.extend({}, options, {
			clientX: this.$element.offset().left + this.elementPosition[0],
			clientY: this.$element.offset().top + this.elementPosition[1]
		}));
		
		return this;
	};
	&#x2F;**
	 * Clicks a mouse button while over an element.
	 *
	 * @method click
	 *
	 * @param {jQuery} [$element] The element to click the mouse button on. It
	 *     will be entered, if it is not already on it
	 * @param {Object} [options] The options to pass to the MouseEventSimulator
	 *
	 * @return {Simulation} The Simulation itself to allow chaining
	 *&#x2F;
	Simulation.prototype.click = function ($element, options) {
		if (!$element) {
			$element = this.$element;
		}
		if (!options) {
			options = {};
		}
		this.press($element);
		this.wait(5);
		this.release(this.$element);
		this.wait(5);
		this.mouseclick(this.$element, $.extend({}, options, {
			clientX: this.$element.offset().left + this.elementPosition[0],
			clientY: this.$element.offset().top + this.elementPosition[1]
		}));
		
		return this;
	};
	
	$.simula = {};
	$.simula.Observer = Observer;
	$.simula.Observable = Observable;
	$.simula.Simulator = Simulator;
	$.simula.SimulatorQueue = SimulatorQueue;
	$.simula.TimeSimulator = TimeSimulator;
	$.simula.EventSimulator = EventSimulator;
	$.simula.SimulaEvent = SimulaEvent;
	$.simula.SimulaUIEvent = SimulaUIEvent;
	$.simula.SimulaMouseEvent = SimulaMouseEvent;
	$.simula.MouseEventSimulator = MouseEventSimulator;
	$.simula.Simulation = Simulation;
	
}(jQuery));
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
